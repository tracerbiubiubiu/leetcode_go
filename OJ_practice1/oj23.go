package main

import "fmt"

/*
   # 二项式展开
   # (1+1)^2n = C(2n,0) + C(2n,1) + ... + C(2n, 2n) = 2^2n
   # (1-1)^2n = C(2n,0) - C(2n,1) + ... + C(2n, 2n) = 0
   # 推理得到 ==> C(2n,1) + C(2n,3) +...+ C(2n, 2n-1) = 2^2n /2 = 2^(2n-1)
   #
   # 由于奇数次系数之和2^(2n-1)不能被奇数整除，所以最大公约数也没有奇数因子。
   # ---> kn1+kn2+k... = k(n1+n2+...) 其中 k 是最大公约数，如果存在其他质数因子，则该数列之和一定能被这个质数因子整除
   # ---> 反证，如果公约数有非2的质数因子，则一定有 数列之和 可以被质数整除，然而2^(2n-1)只有2作为因子，故此不成立
   # ---> 可以得出，最大公约数中，没有2以外的质数因子，也就是说，最大公约数一定是2的幂数
   # ---> 那么我们的目标就是要看数列中{C(2n,1),...,C(2n,2n-1)}，哪个数中的2因子个数最少
   #
   # 在数列中{C(2n,1),...,C(2n,2n-1)}中，从C(2n,1)后的任一项中的2的个数都比 C(2n,1)多，或者相等
   # 证明：
   # C(2n, 2i+1) = 2n * ( A/B )
   # 其中
   # A = (2n-1)(2n-2)...(2n-2i)
   # B = (2i+1)!
   # 只考虑2的个数，如果A中2的个数比B中多，那么在最前面的2n就可以保证该式中 2 的个数一定不比 2n少
   # 所以，只需要证明A中2的个数比B多即可，接下来只看A、B中的偶数位即可
   # A' = (2n-2)...(2n-2i) = 2^i * [(n-1)(n-2)...(n-i)] ===> 提取2
   # B' = 2*4*...*2i = 2^i * i! ===> 提取2
   # A'/B' = (n-1)(n-2)...(n-i)/i! = C(n-1,i) ==> 这个是整数
   # 所以 A中2的个数，一定大于或等于 B中2的个数
   # 所以 C(2n, 2i+1) 中 2 的个数一定大于等于 2n中2的个数
   # 所以 数列中，2n中2的个数最少
   #
   # 以上可以得出，数列相加求和的结果 与 第一项 进行公约数计算，不会扩大最大公约数
   # 最终结论是：求 C(2n,1),c(2n,3)...,c(2n,2n-1)的最大公约数 ，即 求 2n 和 该数列之和（2^(2n-1)） 的公约数
   # gcd(2n, 2^(2n-1)) ，其中2^(2n-1) 的约数都是2的幂数，则该gcd（求最大公约数）操作即为求：2n中有多少个2
   #
   # 一个数中有多少个2 可以考虑二进制的表示
   # 例如：
   # XXXX1000 表示该数中有3个2，即该数可以表示为 8 * Y，也就是看二进制末尾有几个零
   # 当该数-1时就会变为 XXXX0111，按位与运算后得到 XXXX0000 ---> (num & (num - 1))
   # 使用 XXXX1000-XXXX0000 = 1000 即 8 得到所求答案 （3个2 公约数8） ---> num - (num & (num - 1))
   # ====================================
   # 也可以考虑该数与 该数的负数 按位与运算
   # 一个数如XXXX1000其负数为补码 二进制为该数取反码+1，则会变为X'X'X'X'0111+1 = X'X'X'X'1000
   # 则 num & -num 也可得到 1000 这个答案
   #
   # 注意 Python中 +- 优先级比 & 高
   # 以下二选一：
   # print num & -num
   # print num - (num & (num - 1))
*/
func main() {
    var num int
    _, err := fmt.Scanf("%d", &num)
    if err != nil {
        return
    }
    //二项式定理
    num *= 2
    fmt.Println(num & -num)
    fmt.Println(num - (num & (num - 1)))
}
func gcd(a, b int) int {
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}
